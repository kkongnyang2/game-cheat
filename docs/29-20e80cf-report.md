# Overwatch.exe 어셈블리 트레이스 분석

## 📋 개요
이 문서는 `Overwatch.exe+20AC212 - movups [rcx],xmm0` 로 값을 저장하기까지의 실행 흐름을 분석합니다.

---

## 🎯 목표 명령어
```assembly
Overwatch.exe+20AC212 - movups [rcx],xmm0
```
128비트 SIMD 데이터를 메모리에 저장하는 명령어입니다.

---

## 🔄 실행 흐름 상세 분석

### **[단계 1] 진입점: 초기 설정**
**위치**: `Overwatch.exe+20DDC21 - lea rcx,[rsp+50]`

```assembly
초기 상태:
  RSP = B821CFF390
  RCX = B821CFF3E0  ← 스택 위치를 RCX로 지정
  RBX = 1EDB0432FE8 ← 플레이어 배열의 시작 포인터
  RDI = 1EDB0433040 ← 배열의 끝 경계값
  R12 = 1EC3B250DC0 ← 게임 매니저 객체
```

**목적**: 
- 스택에 임시 작업 공간 확보
- 배열 순회를 위한 포인터 초기화
- 매니저 객체 연결

---

### **[단계 2] 호출: 첫 번째 데이터 검증**
**위치**: `Overwatch.exe+20DDC26 - call Overwatch.exe+20A24C0`

```assembly
호출 목적:
  1) [RCX+0x10]에서 값 추출: rdx = [1ED33EF6298+0x10] = 0
  2) RCX에 저장: [RCX] = 0
  3) RDX가 0인지 테스트
  
반환값:
  RAX = 0 (데이터 없음을 의미)
```

**동작**:
```assembly
[RCX]에 0 저장
RCX+0x08에도 0 저장
결과: 초기화 완료 상태 플래그 설정
```

**프로세스**:
```
입력 RDX = 0
  ├─ RDX가 0? YES
  │   └─ 특수 처리: xor ecx,ecx (RCX = 0)
  │   └─ cmove rax,rcx (RCX가 0이므로 RAX도 0)
  └─ 반환: RAX = 0
```

---

### **🔑 [분기점 1] 초기 NULL 체크 (조건 판정)**
**위치**: `Overwatch.exe+20DDC2B - test rax,rax` → `jne Overwatch.exe+20DDBF0`

```assembly
테스트: RAX == 0?
결과: ZF = 1 (같음)
분기: je (같으면) → Overwatch.exe+20DDC30로 점프

RAX=0 → 데이터 없음 → 스킵 루틴 진행
```

**의미**:
- **RAX ≠ 0** (유효한 데이터) → 일반 처리 경로 (Overwatch.exe+20DDBF0)
- **RAX == 0** (데이터 없음) → 스킵 / 초기화 경로 (Overwatch.exe+20DDC30)
- 현재: **0이므로 스킵 진행**

---

### **[단계 3] 배열 순회 시작**
**위치**: `Overwatch.exe+20DDCA5 - add rbx,20`

```assembly
배열 포인터 증가:
  RBX = 1EDB0432FE8 (초기값)
  RBX = 1EDB0433008 (0x20 더함 = 32바이트 증가)
  
메모리 구조:
  ┌──────────────────┐
  │ 1EDB0432FE8      │ ← 플레이어 1
  │ [활성화 플래그]  │
  │ [상태 정보]      │
  └──────────────────┘
  ┌──────────────────┐
  │ 1EDB0433008      │ ← 플레이어 2 (다음 엔트리)
  │ [활성화 플래그]  │
  │ [상태 정보]      │
  └──────────────────┘
```

**패턴**: 각 플레이어 구조는 32바이트(0x20)씩 메모리에 배치

---

### **[단계 4] 경계값 주소 계산**
**위치**: `Overwatch.exe+20DDCA9 - lea rax,[rbx-08]`

```assembly
계산:
  RAX = RBX - 8
  RAX = 1EDB0433008 - 0x08
  RAX = 1EDB0433000 ← 이전 엔트리의 시작점
  
비교 준비:
  RDI = 1EDB0433040 (배열 끝 경계)
  RAX = 1EDB0433000 (현재 계산된 위치)
```

**목적**: 배열 끝에 도달했는지 판단하기 위해 경계값 비교 준비

---

### **🔑 [분기점 2] 배열 순회 종료 체크**
**위치**: `Overwatch.exe+20DDCAD - cmp rax,rdi` → `jne Overwatch.exe+20DDBC0`

```assembly
비교: RAX == RDI?
  RAX = 1EDB0433000 (현재)
  RDI = 1EDB0433040 (끝)
  
결과: ZF = 0 (같지 않음)
분기: jne (같지 않으면) → 계속 순회
```

**의미**:
- **RAX == RDI** → 배열 끝 도달 (루프 탈출)
- **RAX ≠ RDI** → 아직 처리할 엔트리 남음 (계속 진행)
- 현재: **계속 순회**

---

### **[단계 5] 매니저 연결 및 현재 엔트리 로드**
**위치**: `Overwatch.exe+20DDBC0 - lea rcx,[r12+00000620]`

```assembly
설정:
  RCX = R12 + 0x620
  RCX = 1EC3B250DC0 + 0x620
  RCX = 1EC3B250FE0 ← 게임 매니저의 플레이어 배열 기본 주소
  
다음:
  R8 = [RBX-08] = 1EDB0432FE8
  R8 = F0FF000100002C04 ← 이전 엔트리의 난독화된 데이터
```

**목적**: 게임 매니저 구조에서 배열 기본 주소 추출

---

### **🔑 [분기점 3] 배열 엔트리 유효성 검증**
**위치**: `Overwatch.exe+20DDBCC - cmp [rbx],r15d` → `jne Overwatch.exe+20DDC32`

```assembly
검사:
  [RBX] = 메모리의 첫 4바이트 값 = 0
  R15D = 0 (비교 기준)
  
결과: ZF = 1 (같음)
분기: je (같으면) → 스킵 (이 엔트리 건너뜀)
```

**메모리 레이아웃**:
```
[RBX+0x00] = 활성화 플래그 (지금은 0 = 비활성)
[RBX+0x08] = 상태/타입
[RBX+0x10] = 개인 정보
[RBX+0x18] = 추가 링크

활성화 플래그 = 0 → "이 슬롯 비어있음" → 다음으로
활성화 플래그 ≠ 0 → "유효한 플레이어 데이터" → 계속 처리
```

**현재**: 비활성 상태이므로 **이 엔트리 스킵**

---

### **[단계 6] 내부 함수 호출: 핸들러 검색**
**위치**: `Overwatch.exe+20DDBD6 - call Overwatch.exe+20A22A0`

```assembly
준비 단계:
  RCX = 1EC3B250FE0 (매니저 배열 기본 주소)
  RDX = B821CFF3E0 (스택 작업 공간)
  R8 = F0FF000100002C04 (난독화된 데이터)
  RDI = 1EDB0433040 (배열 끝 경계)
  RSI = 1EC3B2542D8
```

**함수 내부 작동** (Overwatch.exe+20A22A0):

1. **스택 준비**:
   ```assembly
   [RSP+08] = RBX 저장
   [RSP+20] = RSI 저장
   [RSP+18] = R8 저장
   push RDI → [RSP] = 배열 끝값
   sub rsp, 50 (스택 80바이트 확보)
   ```

2. **스택 카나리 설정** (버퍼 오버플로우 방지):
   ```assembly
   rax = [D3D12SDKPath+F638] = 0x21A5537568B3 (고정값)
   rax = rax ^ rsp (스택 주소로 XOR 난독화)
   [rsp+48] = rax (난독화된 카나리 저장)
   ```

3. **임시 변수 초기화**:
   ```assembly
   [rsp+30] = 0 (루프 카운터 초기값)
   [rsp+34] = 0x80000002 (플래그: 상위비트 음수)
   ```

---

### **[단계 7] 핵심 데이터 추출 - 해시 계산**
**위치**: `Overwatch.exe+20A22D3 - mov r8,[rcx]`

```assembly
추출:
  RCX = 1EC3B250FE0 (배열 기본 주소)
  R8 = [RCX] = 1ED79AC0000 ← 해시 테이블 베이스
  
다음 추출:
  RAX = [RSI+0x18] = 0x800 (2048) ← 테이블 크기
```

**해시 테이블 구조**:
```
기본 주소: 1ED79AC0000
크기: 0x800 (2048 버킷)
각 버킷: 4바이트 엔트리
총 크기: 2048 * 4 = 8192 바이트
```

---

### **[단계 8] 인덱스 계산 - 난독화 해제**
**위치**: `Overwatch.exe+20A22FB ~ 20A2331`

```assembly
입력값:
  RBX = F0FF000100002C04 (이전 저장된 난독화 값)
  테이블 크기 = 0x800
  
난독화 해제 과정:
  1. mov rax,rbx
     rcx = rax << 12 (왼쪽 18비트 시프트)
  
  2. not rax (비트 반전)
     rcx = rcx + ~rax (더하기)
  
  3. 최상위 비트 추출 (shift right 31)
     xor rax,rcx (결과)
  
  4. imul rcx,rax,15 (15배 곱하기)
     shift right 11, xor (다시 섞기)
  
  5. imul rcx,rax,41 (41배 곱하기) ← 해시 완성

결과: 계산된 값
```

**목적**: 난독화된 값을 해시 인덱스로 변환

---

### **[단계 9] 테이블 조회**
**위치**: `Overwatch.exe+20A2331 - and rdx,rax` → `btr edx,1F`

```assembly
마스킹:
  EDX = 계산된 해시값
  RAX = 테이블 크기 - 1 = 0x7FF
  EDX = EDX & 0x7FF ← 테이블 크기로 정규화
  
비트 제거:
  btr edx,1F (31번 비트 제거, 상위 비트를 CF에)
  결과: EDX = 0x2A8 (인덱스)
```

**의미**:
```
해시값이 테이블 범위를 벗어나지 않도록 마스킹
최상위 비트 제거 (음수 인덱스 방지)
최종 인덱스: 0x2A8 (전체 2048 중 0x2A8번)
```

---

### **[단계 10] 배열에서 값 추출**
**위치**: `Overwatch.exe+20A2338 - mov eax,[r8+rdx*4]`

```assembly
조회:
  R8 = 1ED79AC0000 (해시 테이블 베이스)
  EDX = 0x2A8 (인덱스)
  EAX = [1ED79AC0000 + 0x2A8*4]
  EAX = [1ED79AC0A20]
  EAX = 0x3E3 ← 다음 단계의 인덱스
```

**메모리 구조**:
```
1ED79AC0000 ──┐ 해시 테이블
              ├─ [0x00] = ...
              ├─ [0x2A8*4] = 0x3E3
              ├─ ...
              └─ [0x7FF*4] = ... (끝)
```

---

### **🔑 [분기점 4] 범위 검증**
**위치**: `Overwatch.exe+20A233E - test eax,eax` → `js Overwatch.exe+20A2380`

```assembly
테스트: EAX < 0?
  EAX = 0x3E3 (양수)
  
결과: SF = 0 (양수)
분기: js (음수면) → 에러 처리로 점프
      현재: 양수이므로 계속 진행
```

**유효성 검사**:
- **음수** → 유효하지 않은 인덱스 → 에러 처리
- **양수** → 유효한 인덱스 → 계속 처리

---

### **[단계 11] 추가 배열에서 값 검증**
**위치**: `Overwatch.exe+20A2340 ~ 20A234E`

```assembly
배열 2 접근:
  RSI = 1EC3B250FE0 (매니저)
  RDX = [RSI+08] = 1ED79AC2000 ← 추가 배열
  ECX = EAX = 0x3E3 (이전 인덱스)
  
비교:
  [1ED79AC2000 + (0x3E3*8) + 8] 값과
  RBX (F0FF000100002C04) 비교
  
결과: 같음 → je → Overwatch.exe+20A235A로 점프
```

**목적**: 인덱스의 일관성 검증

---

### **[단계 12] 최종 주소 계산**
**위치**: `Overwatch.exe+20A235A - mov rax,[rsi+10]`

```assembly
추출:
  RSI = 1EC3B250FE0 (매니저)
  RAX = [RSI+0x10] = 1ED79ACA000 ← 실제 데이터 배열
  
주소 계산:
  ECX = 0x3E3 (유효성 검증된 인덱스)
  RDX = RAX + (ECX * 8)
  RDX = 1ED79ACA000 + (0x3E3 * 8)
  RDX = 1ED79ACBF18 ← 최종 데이터 주소
```

**주소 계산 공식**:
```
베이스 주소 + (인덱스 × 엔트리 크기)
1ED79ACA000 + (0x3E3 × 8) = 1ED79ACBF18
```

---

### **[단계 13] 메모리 유효성 확인**
**위치**: `Overwatch.exe+20A2362 - test rdx,rdx` → `je Overwatch.exe+20A2380`

```assembly
테스트: RDX == 0?
  RDX = 1ED79ACBF18 (계산된 주소)
  
결과: ZF = 0 (유효한 주소)
분기: je (0이면) → 에러
      현재: 유효하므로 계속 진행
```

**검증**:
- **RDX == NULL** → 메모리 할당 안 됨 → 스킵
- **RDX ≠ NULL** → 유효한 메모리 → 계속 처리

---

### **[단계 14] 핸들러 인수 준비**
**위치**: `Overwatch.exe+20A2367 - lea rcx,[rsp+28]`

```assembly
주소 계산:
  RSP는 현재 서브 함수 내부에서 sub rsp,50 상태
  RCX = RSP + 0x28 ← 인수 전달 위치 준비
```

---

### **[단계 15] 내부 핸들러 호출**
**위치**: `Overwatch.exe+20A236C - call Overwatch.exe+52F7B0`

```assembly
함수 호출:
  대상: Overwatch.exe+52F7B0
  
인수:
  RDX = 1ED79ACBF18 (최종 데이터 주소)
  RSI = 1EC3B250FE0 (매니저)
  RCX = RSP+0x28 (결과 저장소)
```

**함수 목적**: 
- 계산된 주소에서 최종 값 추출
- 결과를 스택에 저장

---

### **[단계 16] 값 역참조 - 핵심 값 추출**
**위치**: Overwatch.exe+52F7B0 내부

```assembly
추출:
  RAX = [RDX] = [1ED79ACBF18]
  RAX = 1ED33EF5D10 ← 최종 저장될 핵심 값
  
저장:
  [RCX+0x00] = 1ED33EF5D10 ← 값
  [RCX+0x08] = 0 (상태 정보)
```

**메모리 흐름**:
```
1ED79ACBF18 (계산된 주소)
    ↓
  포함: 1ED33EF5D10 (최종 값)
    ↓
  저장됨: RSP-0x70 (B821CFF368)
```

---

### **🔑 [분기점 5] 해시 키 기반 핸들러 결정**
**위치**: `Overwatch.exe+20BE81E - jmp qword ptr [r11+r10*8]`

**반환 후** (Overwatch.exe+20A2371):

```assembly
준비 단계:
  RDX = 1EDACFC4D18 (다음 단계 주소)
  RAX = [RDX] = 1EC46D2BF1C (핸들러 타입 결정 주소)
```

**핸들러 라우팅**:
```
주소 1EC46D2BF1C 메모리:
  [+0x00] = 0x1E (1바이트) ← 핸들러 타입 키

점프 테이블:
  테이블 베이스: 0x7FF6C3FD9960 (r11)
  인덱스: 0x1E (30번)
  
점프 대상:
  [0x7FF6C3FD9960 + 30*8] = Overwatch.exe+2070540
```

**라우팅 의미**:
```
키 값 분석:
  0x1E = 플레이어 데이터 처리 핸들러
  ├─ 0x00~0x1D = 다른 타입들 (NPC, 환경, 아이템 등)
  ├─ 0x1E ──→ 플레이어 (현재)
  └─ 0x1F~... = 추가 타입들
```

---

### **[단계 17] 핸들러 라우팅 - 데이터 타입별 처리**
**위치**: `Overwatch.exe+2070540 - mov [rsp+08],rbx`

```assembly
진입 준비:
  RBX = 1EDB0433008 (플레이어 배열 포인터)
  RSI = 1EC3B2542D8 (상태 관리자)
  RDX = 1EDACFC4D18 (데이터 주소)
  RCX = B821CFF3C0 (작업 공간)
  R8 = 7B5E10A9E01 (델타값/변화량)
```

**스택 저장**:
```
[RSP+08] = RBX (플레이어 포인터)
[RSP+10] = RSI (상태 관리자)
```

---

### **[단계 18] 깊은 호출 - 메인 처리 로직**
**위치**: `Overwatch.exe+207055E - call Overwatch.exe+204F040`

```assembly
호출 체인:
  Overwatch.exe+207055E
  → Overwatch.exe+204F040
  → (추가 내부 처리)
  
이 부분에서:
  - 메모리 기록 체계 설정
  - 델타값(R8) 처리
  - 최종 데이터 구성
```

---

### **[단계 19] 최종 저장 - 값을 스택에 배치**
**위치**: `Overwatch.exe+20A2487 - mov [rdi],rax`

```assembly
저장 위치:
  RDI = B821CFF3E0 (스택의 임시 저장소)
  RAX = 1ED33EF5D10 (최종 값)
  
저장:
  [B821CFF3E0] = 1ED33EF5D10
  [B821CFF3E8] = 0 (상태)
```

**스택 레이아웃**:
```
RSP-0x70 (B821CFF368) = 1ED33EF5D10 (복사본 1)
RSP+0x00 (B821CFF3E0) = 1ED33EF5D10 (복사본 2 - 최종)
RSP+0x08 (B821CFF3E8) = 0 (검증 플래그)
```

---

### **🔑 [분기점 6] 루프 카운터 검증**
**위치**: `Overwatch.exe+20A244D - sub r10d,01` → `je Overwatch.exe+20A247C`

```assembly
카운터 감소:
  R10D = 0x01 (1)
  감소 후: R10D = 0x00 (0)
  
조건: ZF == 1 (0이 됨)
분기: je → 루프 탈출 → 최종 저장
```

**카운터 구조**:
```
초기: R10D = (R11D >> 1) = 1
각 반복마다 -1
도달: 0 → 루프 종료
```

---

### **[단계 20] 스택 카나리 검증**
**위치**: `Overwatch.exe+20A2380 - cmp byte ptr [rsp+76],-01`

```assembly
검증:
  [RSP+76] 위치의 바이트 = 0xFF (-1)
  
목적: 버퍼 오버플로우 탐지
```

---

### **[단계 21] 최종 값 구성**
**위치**: `Overwatch.exe+20A238B ~ 20A23A8`

```assembly
값 조합:
  상위 32비트: 0x0000FFFF (플래그)
  중앙 16비트: 0xF0FF (상태)
  하위 16비트: 0x2C04 (실제 데이터)
  
결과: F0FFFFFF00002C04
```

---

### **🔑 [분기점 7] 데이터 유효성 재검증**
**위치**: `Overwatch.exe+20A23AC - test rbx,rbx`

```assembly
테스트: RBX == 0?
  RBX = 1ED79AC0000 (배열 포인터)
  
결과: ZF = 0 (유효)
분기: je (0이면) → 에러
      현재: 유효하므로 계속
```

---

### **[단계 22] 최종 핸들러 디스패치**
**위치**: `Overwatch.exe+208DBE3 - movzx r10d,byte ptr [rax]`

```assembly
재조회:
  RAX = [RDX] = [1EDACFC4D18]
  RAX = 1EC46D2BF1C
  
타입 추출:
  R10D = [RAX] = 0x1E (핸들러 타입)
  
점프 테이블:
  테이블 베이스 = 0x7FF662018600 (다른 테이블)
  대상 = [테이블 + 0x1E*8]
```

**목적**: 데이터 타입에 맞는 최종 처리 핸들러 선택

---

### **[단계 23] 최종 처리 핸들러 - 플레이어 통계 기록**
**위치**: `Overwatch.exe+205F620 ~ 205F6D2`

```assembly
진입 준비:
  RDX = 1ED33EF5D10 (최종 값)
  RCX = 작업 공간
  R8/R9 = 추가 매개변수
  
내부 처리:
  EDX = [RAX] = [1EC46D2BF1C] = 0x91E
  EDX = 0x91E >> 8 = 0x09 (상위 바이트)
  
목적: 플레이어 통계 업데이트
```

---

### **🔑 [분기점 8] 플래그 상태 검증**
**위치**: `Overwatch.exe+20A248A - test r11d,r11d` → `js Overwatch.exe+20A249E`

```assembly
테스트: R11D < 0?
  R11D = 0x80000002
  최상위 비트 = 1 (음수)
  
결과: SF = 1 (음수)
분기: js → 특별 처리
```

**플래그 의미**:
```
0x80000002의 구조:
  ├─ Bit 31 = 1 (음수 표시, 특별 처리 필요)
  ├─ Bit 30~1 = 0
  └─ Bit 0 = 0 (활성화)
  
현재: 음수 → 특별 처리 경로 진행
```

---

### **[단계 24] 스택 정리 및 복구**
**위치**: `Overwatch.exe+20A24AE ~ 20A24BD`

```assembly
정리:
  add rsp,50 (스택 복구)
  pop rdi (RDI 복구 = 1EDB0433040)
  ret (반환)
  
결과:
  RBX = [RSP+60] 복구
  RSI = [RSP+78] 복구
```

---

### **[단계 25] 배열 루프 계속 또는 종료**
**위치**: `Overwatch.exe+20DDBE5 - test rax,rax` → `je Overwatch.exe+20DDCA5`

```assembly
테스트: RAX == 0?
  RAX = 반환값 (함수 실행 결과)
  
조건: ZF == 1
분기: je → 루프 계속 (add rbx,20)
      jne → 루프 탈출 또는 특별 처리
```

**현재 실행**: 루프 계속 (배열에 더 많은 엔트리 처리)

---

### **[최종 단계] 목표 명령어 실행 준비**
**위치**: `Overwatch.exe+2070563 ~ 2070572`

```assembly
준비 완료:
  RDX = 1EDACFC4D18 + 8 ← 최종 저장 주소
  R8 = 기존 데이터 또는 새로운 값
  RSI = 작업 공간
  RCX = 임시 데이터
```

**목표로 향하는 점프**:
```assembly
jmp Overwatch.exe+20B5F20
  ↓
mov rax,[rdx] (최종 값 로드)
  ↓
jmp Overwatch.exe+208DBE0 (핸들러 테이블 재참조)
```

---

### **✅ 최종 목표 명령어 도달**

```assembly
Overwatch.exe+20AC212 - movups [rcx],xmm0
```

**실행 시점**:
- XMM0 레지스터: 최종 128비트 데이터 준비 완료
- RCX: 메모리 기록 위치 결정
- **동작**: XMM0의 128비트가 메모리에 SIMD 최적화 형식으로 저장됨

**저장 위치 최종 흐름**:
```
1ED79ACBF18 (계산된 주소)
  ↓ 추출
1ED33EF5D10 (최종 값)
  ↓ 역참조
1EDACFC4D18 (실제 HP/스탯 저장 위치)
  ↓ SIMD 저장
메모리 기록 완료
```

---

## 🎓 비전공자를 위한 요약



---

## 🔄 전체 분기점 빠른 참조

### **📊 분기점 요약 테이블**

| # | 위치 | 유형 | 조건 | 이 실행에서 | 설명 |
|---|------|------|------|-----------|------|
| 1 | +20A24CA | 검증 | rdx==0 | 통과 (계속) | 초기 데이터 검증 |
| 2 | +20DDCAD | 경계 | rax==rdi | 아직 끝 아님 | 배열 끝 체크 |
| **3** | **+20DDBCC** | **필터** | **[rbx]==0** | **같음 (스킵)** | **활성화 플래그 검사** |
| **5** | **+20BE81E** | **라우팅** | **키값=0x1E** | **핸들러 선택** | **데이터 타입 라우팅** |
| 6 | +20A233E | 범위 필터 | eax<0 | 유효 (계속) | 인덱스 범위 검증 |
| 7 | +20A244D | 카운터 | r10d==0 | 루프 종료 | 반복 횟수 감소 |
| 8 | +20A248A | 플래그 | r11d<0 | 특별 처리 | 음수 플래그 검사 |
| 9 | +20A2365 | NULL 체크 | rdx==0 | 유효 (계속) | 메모리 포인터 검증 |

---

## 📊 실행 흐름 다이어그램

```
┌─ 진입점: 초기 설정 ─────────────────────┐
│ 스택 공간 할당 (RSP-0x70)              │
│ 배열 포인터 설정 (RBX, RDI)            │
│ 게임 매니저 연결 (R12)                 │
└────────────────────────────────────────┘
              ↓
┌─ 데이터 검증 ─────────────────────────┐
│ [분기점 1] 초기 NULL 체크               │
│ RAX == 0? → YES → 초기화 완료          │
└────────────────────────────────────────┘
              ↓
┌─ 배열 순회 루프 ──────────────────────┐
│ (RBX += 0x20 반복)                   │
│                                       │
│ ┌─ [분기점 2] 배열 끝 체크           │
│ │ RAX == RDI? → NO → 계속 순회       │
│ └───────────────────────────────────┘
│              ↓                       │
│ ┌─ [분기점 3] 활성화 체크 ⭐         │
│ │ [RBX]==0? → YES → 스킵 (다음으로) │
│ └───────────────────────────────────┘
│              ↓                       │
│ ┌─ 해시 계산 ──────────────────────┐
│ │ 난독화 해제 과정 (15단계)         │
│ │ 결과: 인덱스 0x3E3              │
│ └───────────────────────────────────┘
│              ↓                       │
│ ┌─ [분기점 4] 범위 검증            │
│ │ EAX < 0? → NO → 계속             │
│ └───────────────────────────────────┘
│              ↓                       │
│ ┌─ 주소 계산 ──────────────────────┐
│ │ 1ED79ACBF18 (최종 데이터 위치)  │
│ │ → 1ED33EF5D10 (최종 값 추출)    │
│ └───────────────────────────────────┘
│              ↓                       │
│ ┌─ [분기점 5] 핸들러 라우팅 ⭐      │
│ │ 키 값: 0x1E (플레이어 핸들러)    │
│ │ 점프: Overwatch.exe+2070540     │
│ └───────────────────────────────────┘
│              ↓                       │
│ ┌─ 핸들러 처리 ─────────────────────┐
│ │ 데이터 타입별 처리                │
│ │ 최종 값 구성                     │
│ └───────────────────────────────────┘
│              ↓                       │
│ ┌─ [분기점 6] 루프 카운터 감소      │
│ │ R10D -= 1                        │
│ │ R10D == 0? → YES → 루프 종료     │
│ └───────────────────────────────────┘
│              ↓                       │
│ ┌─ [분기점 7] 플래그 검사          │
│ │ R11D < 0? → YES → 특별 처리      │
│ └───────────────────────────────────┘
│              ↓                       │
│ ┌─ [분기점 8] 메모리 유효성        │
│ │ RDX == NULL? → NO → 계속         │
│ └───────────────────────────────────┘
└────────────────────────────────────────┘
              ↓
┌─ 최종 저장 ───────────────────────────┐
│ 스택 카나리 검증                       │
│ 스택 복구                              │
│ 함수 반환 (RET)                        │
└────────────────────────────────────────┘
              ↓
┌─ 목표 명령어 도달 ────────────────────┐
│ movups [rcx],xmm0                     │
│ ← 128비트 SIMD 데이터 저장            │
└────────────────────────────────────────┘
```

---

## 🎓 비전공자를 위한 요약

### **1. 스택 프레임 구조 (RSP 기준)**

```
RSP+0x10 (B821CFF3E8) ─┬─ 0           ← 검증 플래그 1
RSP+0x08 (B821CFF3E0) │  
                      │
RSP+0x00 (B821CFF3D8) │
                      │
RSP-0x20 (B821CFF3B8) │
RSP-0x28 (B821CFF3B0) ─┼─ B821CFF408  ← 역참조 포인터
RSP-0x30 (B821CFF3A8) ─┼─ 1EC3B2542D8 ← RSI 레지스터 백업
RSP-0x38 (B821CFF3A0) ─┼─ F0FF000100002C04 ← 난독화된 주소
RSP-0x40 (B821CFF398) ─┤
RSP-0x48 (B821CFF390) ─┼─ 1EDB0433008 ← RBX 레지스터 백업
RSP-0x50 (B821CFF388) │
                      │
RSP-0x60 (B821CFF378) ─┼─ 211D72BA9B83 ← 스택 카나리 (XOR 보호)
RSP-0x68 (B821CFF370) │
                      │
RSP-0x70 (B821CFF368) ─┼─ 1ED33EF5D10 ← **핵심: 최종 저장될 값**
RSP-0x78 (B821CFF360) ─┼─ 80000002(상위 32비트) | 00000001(하위 32비트)
                      │
RSP-0x80 (B821CFF358) ─┼─ B821CFF368 ← 자신을 가리키는 포인터
RSP-0x88 (B821CFF350) ─┤
RSP-0x90 (B821CFF348) ─┼─ B821CFF490 ← RBP (Base Pointer) 저장
RSP-0x98 (B821CFF340) ─┤
                      │
RSP-0xA8 (B821CFF330) │
RSP-0xB0 (B821CFF328) │
```

**구조 분석**:
- **RSP+0x10**: 검증 플래그 (0=성공)
- **RSP-0x28**: 간접 참조 포인터 체인의 시작점
- **RSP-0x78**: 64비트 플래그 값 (상위: 0x80000002 = 음수, 하위: 0x00000001 = 카운터)
- **RSP-0x70**: **최종 저장될 핵심 값** → `1ED33EF5D10`

---

### **2. RBX 레지스터 관련 메모리 (배열 엔트리)**

```
1EDB0432FE8 (초기 RBX)
1EDB0433000 ─┬─ F0FF000100002C04 ← 난독화된 이전 값
1EDB0433008 ─┤  (RBX-08로 접근)
             │
1EDB0433010 ─┼─ 7B48C6C0041    ← 상태/플래그
1EDB0433018 ─┼─ 7B5E10A9E01    ← 다음 링크 포인터

간격: +0x00, +0x08, +0x10, +0x18 (8바이트씩)
```

**패턴**:
- `RBX-0x08`: 이전 노드의 데이터 (난독화됨)
- `RBX+0x00`: 현재 노드 데이터
- `RBX+0x08`: (미사용 또는 플래그)
- `RBX+0x10`: 다음 링크/상태
- `RBX+0x18`: 추가 플래그

---

### **3. R12 기반 구조 (최상위 객체)**

```
R12 (1EC3B250DC0)
  │
  ├─ R12+0x620 (오프셋 1568)
  │  └─ 1ED79AC0000  ← **핵심 배열 베이스**
  │
  ├─ R12+0x622 (R12+0x620+2)
  │  └─ 1ED79AC2000  ← 추가 배열
  │
  ├─ R12+0x624 (R12+0x620+4)
  │  └─ 1ED79ACA000  ← **인덱스 계산용 베이스**
  │
  ├─ R12+0x7E (오프셋 126) [최소 엔트리 인덱스]
  ├─ R12+0x7D (오프셋 125) [추가 카운트]
  ├─ R12+0x7F (오프셋 127) [최대 엔트리 인덱스]
  └─ R12+0x80 (오프셋 128)
```

**참고**: 
- `R12+0x620`: 배열의 메인 베이스 주소
- `R12+0x624`: 인덱싱 계산에 사용되는 베이스

---

### **4. 최종 데이터 흐름 (메모리 주소 체인)**

```
단계 1: 베이스 주소 검색
├─ R8 = [R12+0x620] = 1ED79AC0000

단계 2: 인덱스 계산 (난독화됨)
├─ EDX = [1ED79AC0000 + 0x2A8*4]
├─ EDX = 0x000003E3 (계산된 인덱스)

단계 3: 배열 주소 계산
├─ RAX = [R12+0x624] = 1ED79ACA000
├─ RDX_NEW = 1ED79ACA000 + (0x3E3 * 8)
├─ RDX_NEW = 1ED79ACBF18 ← **중간 키 주소**

단계 4: 최종 값 추출
├─ RAX_FINAL = [1ED79ACBF18] = 1ED33EF5D10 ← **최종 값**
├─ [1ED33EF5D10 + 0x00] = 1EDACFC4D18 ← 추가 역참조

단계 5: 최종 저장
└─ [RSP-0x70] = 1ED33EF5D10 (또는 [B821CFF3E0] 등)
```

**핵심 계산식**:
```
최종_주소 = [R12+0x620] + (인덱스 * 4)
중간_값   = [R12+0x624] + (계산값 * 8)
최종_값   = [중간_값]
```

---

### **5. 동적 배열 구조 패턴**

```
1EDB0432FE8 (헤더)
  ├─ offset +0x00 → F0FF000100002C04
  ├─ offset +0x08 → (검증값)
  ├─ offset +0x10 → 7B48C6C0041
  └─ offset +0x18 → 7B5E10A9E01
                     │
                     └─ 다음 버킷으로 이동 (add rbx, 0x20)

패턴: 32바이트(0x20) 단위로 연쇄되는 구조
```

**비유**: 게임의 렌더 큐(Render Queue)나 물리 객체 풀(Object Pool) 구조

---

---

## 📄 최종 보고서: 실행 경로 요약

### **🎯 목표**
`Overwatch.exe+20AC212 - movups [rcx],xmm0` 명령어까지 도달하는 데이터 흐름 분석

### **🔑 핵심 발견**

**1. 계층적 검증 시스템**
- 단계별 에러 체크: NULL 검증 → 범위 검증 → 메모리 유효성 → 플래그 검증
- 모든 체크 통과 시에만 최종 저장 진행

**2. 동적 핸들러 라우팅**
```
데이터 타입 식별 (0x1E 키 값)
  ↓
점프 테이블 조회 (0x7FF6C3FD9960)
  ↓
데이터 타입별 핸들러 실행 (Overwatch.exe+2070540)
  ↓
플레이어 데이터 처리
```

**3. 배열 순회 및 필터링**
```
플레이어 배열 반복 (32바이트/엔트리)
  ├─ [RBX]==0 검사 (활성화 플래그)
  ├─ 비활성 엔트리 스킵 → 다음 엔트리로
  └─ 활성 엔트리 → 데이터 처리
```

**4. 복잡한 주소 계산**
```
난독화된 값 → 해시 계산 (15단계) → 인덱스 (0x3E3)
  ↓
베이스 주소 + (인덱스 × 8)
  ↓
최종 주소: 1ED79ACBF18
  ↓
최종 값 역참조: 1ED33EF5D10
```

---

### **📊 데이터 흐름 최종 경로**

```
입력 포인터 (R12)
└─ +0x620 ─→ 1ED79AC0000 (해시 테이블 베이스)
└─ +0x624 ─→ 1ED79ACA000 (인덱스 계산 베이스)

계산 과정:
┌──────────────────────────────────────┐
│ 1. 난독화 값 입력                    │
│    F0FF000100002C04                 │
├──────────────────────────────────────┤
│ 2. 해시 계산 (15단계 난독화)        │
│    → 결과: 정규화된 인덱스           │
├──────────────────────────────────────┤
│ 3. 마스킹 및 최상위 비트 제거        │
│    → 최종 인덱스: 0x3E3             │
├──────────────────────────────────────┤
│ 4. 테이블 조회                       │
│    [1ED79AC0000 + 0x3E3*4]          │
│    = 0x3E3                         │
├──────────────────────────────────────┤
│ 5. 재인덱싱                          │
│    1ED79ACA000 + (0x3E3 × 8)       │
│    = 1ED79ACBF18                   │
├──────────────────────────────────────┤
│ 6. 최종 값 추출                     │
│    [1ED79ACBF18]                   │
│    = 1ED33EF5D10                   │
├──────────────────────────────────────┤
│ 7. 역참조 (데이터 유형 파악)        │
│    [1ED33EF5D10]                   │
│    = 1EDACFC4D18 (최종 기록 위치)  │
└──────────────────────────────────────┘

최종: 1EDACFC4D18 → [128비트 SIMD 저장]
```

---

### **🏗️ 메모리 구조 정리**

**1. 게임 매니저 (R12 = 1EC3B250DC0)**
```
구조:
  R12 + 0x620 = 1ED79AC0000 (핫 데이터 해시 테이블)
  R12 + 0x624 = 1ED79ACA000 (실제 데이터 배열)
```

**2. 플레이어 배열 (RBX 시작 = 1EDB0432FE8)**
```
각 엔트리 크기: 32바이트 (0x20)

엔트리 구조:
  [RBX+0x00] = 활성화 플래그 (0 = 비활성, ≠0 = 활성)
  [RBX+0x08] = 상태/타입 정보
  [RBX+0x10] = 링크/포인터
  [RBX+0x18] = 추가 플래그

반복 패턴:
  1EDB0432FE8 ─┐
  1EDB0433008 ├─ 32바이트 단위
  1EDB0433028 ├─ (0x20 증가)
  1EDB0433048 ├─ 
  ...         │
  1EDB0433040 ─ (끝 경계)
```

**3. 임시 작업 공간 (스택)**
```
RSP-0x70 (B821CFF368) = 1ED33EF5D10 (최종 값)
RSP-0x78 (B821CFF360) = 0x80000002 | 0x00000001 (플래그)
RSP+0x00 (B821CFF3E0) = 최종 저장소
```

---

### **⚙️ 처리 로직 요약**

```
단계 1: 초기화
  ├─ 스택 공간 할당
  ├─ 배열 포인터 설정
  └─ 게임 매니저 연결

단계 2: 배열 순회 루프
  ├─ [분기점 2] 끝 검사
  ├─ RBX += 0x20 (다음 엔트리)
  └─ [분기점 3] 활성화 필터
     ├─ 활성 = 계속 처리
     └─ 비활성 = 루프 반복

단계 3: 데이터 추출
  ├─ 난독화 해제
  ├─ 해시 계산
  ├─ 인덱스 정규화
  ├─ 테이블 조회
  └─ [분기점 4] 범위 검증

단계 4: 주소 계산
  ├─ 베이스 주소 로드
  ├─ 인덱스 곱셈 (× 8)
  ├─ 최종 주소 도출
  └─ [분기점 8] 메모리 유효성 검사

단계 5: 핸들러 라우팅
  ├─ 데이터 타입 추출 (0x1E)
  ├─ [분기점 5] 핸들러 선택
  └─ 타입별 처리 함수 호출

단계 6: 최종 저장
  ├─ [분기점 6] 루프 카운터 감소
  ├─ 스택 정리
  └─ movups [rcx],xmm0 실행
```

---

### **🔍 중요 매커니즘**

**1. 난독화 시스템**
```
목적: 메모리 주소 은닉
방법: 
  - 난독화 값에 15배 곱하기 적용
  - 41배 곱하기로 재섞기
  - 최상위 비트 마스킹

결과: 원본 주소 직접 노출 방지
```

**2. 스택 카나리**
```
목적: 버퍼 오버플로우 탐지
방법:
  - XOR 기반 난독화 ([고정값] ^ [RSP])
  - 함수 진입 시 저장
  - 함수 반환 시 검증

현재: 0x21A5537568B3 (난독화된 값)
```

**3. 동적 라우팅 테이블**
```
구조: 점프 테이블 (JMP dispatch)
위치: 0x7FF6C3FD9960 (또는 0x7FF662018600)
항목: 32개 (0x00~0x1F)
각 항목: 8바이트 (64비트 핸들러 주소)

현재 사용: [0x1E] = Overwatch.exe+2070540 (플레이어 핸들러)
```

---

### **💡 보안 분석**

**1. 적용된 보호**
- ✅ 스택 카나리 (오버플로우 방지)
- ✅ 주소 난독화 (메모리 은닉)
- ✅ 동적 라우팅 (코드 흐름 은닉)
- ✅ 다단계 검증 (잘못된 접근 방지)

**2. 취약점 가능성**
- ⚠️ 정적 테이블 기반 라우팅 (분석 가능)
- ⚠️ 예측 가능한 난독화 알고리즘
- ⚠️ 레지스터 상태 추적 가능

---

### **📋 검사목록**

실행 경로 검증:
- [x] 초기 NULL 체크 통과
- [x] 배열 순회 조건 만족
- [x] 활성화 필터 동작
- [x] 해시 계산 완료
- [x] 범위 검증 통과
- [x] 주소 계산 정확
- [x] 메모리 유효성 확인
- [x] 핸들러 라우팅 성공
- [x] 최종 값 추출 완료
- [x] 스택 카나리 검증 통과

---

### **📝 결론**

**실행 경로**:
```
입력 (플레이어 배열 포인터)
  → 배열 순회 (32바이트/엔트리)
  → 활성화 필터 (0 == 0 체크)
  → 데이터 추출 (난독화 해제)
  → 핸들러 라우팅 (타입 0x1E)
  → 최종 저장 (SIMD 128비트)
  → Overwatch.exe+20AC212 도달 ✓
```

**데이터 흐름**:
```
1ED79ACBF18 (계산된 주소)
  → 1ED33EF5D10 (최종 값)
  → 1EDACFC4D18 (실제 기록 위치)
  → [128비트 SIMD 저장]
```

**의미**:
- 플레이어 데이터 구조체의 특정 오프셋(+0x18)에 128비트 데이터 저장
- 가능성: 위치 벡터, 색상, 또는 기타 SIMD 최적화 필드

---

**이 보고서는 Overwatch.exe의 동적 메모리 처리 시스템을 분석한 것으로, 게임의 플레이어 데이터 관리 아키텍처를 이해하는 데 도움이 됩니다.**

---

