### esp

네트워크 복제: 서버가 AOI(관심영역) 안의 엔티티 상태(위치, 체력 등)를 내려줌 → 클라 ECS에 반영.

가시성 선별(클라):
뷰 프러스텀 컬링: 카메라 시야 밖이면 제외
포털/PVS/룸 시스템: 같은 공간만 남김(있는 게임)
오클루전 컬링(Hi-Z/쿼리): 벽 등으로 가려진 건 제외
LOD/거리/팀 규칙으로 추가 제외

드로우 리스트 생성: 위 필터를 통과한 것만 드로우콜 생성 → GPU 렌더링
→ 보통 **가려진 적은 ‘논리 데이터는 업데이트되지만, 메인 패스엔 드로우콜 자체가 없음’**이 정석.

따라서 component에 있는 모든 적의 위치 정보를 바탕으로 내가 직접 렌더링을 해줘야함.


### 트리거봇

아이디어: 로컬 클라이언트가 가진 적 좌표/본을 읽고, 내 시야 벡터·FOV와의 각도/거리가 임계치 이하면 발사.



### 내가 찾아야 할 정보

일단 전체 런타임 메모리 구조를 어느정도 파악.
헤드인지, 몸샷인지, 미스인지를 판별하는 변수를 찾아서 화면에 perfect/good/miss 띄어주기.

| 패턴                    | 구조 예시                                                              | 특징 & 힌트                                                                  |
| --------------------- | ------------------------------------------------------------------ | ------------------------------------------------------------------------ |
| **① Boolean 플래그**     | `c++ uint8_t bCrosshairOnEnemy; // 0/1`                            | \* 가장 단순·보편<br>\* 값이 0↔1만 변하므로 CE에서는 **1 Byte, Exact value**(0/1) 필터가 유효 |
| **② Enum/Bit-field**  | `c++ uint8_t CrosshairState; // 0 none, 1 enemy, 2 ally, 3 object` | \* 팀識別·NPC 구분이 필요한 게임<br>\* 스캔 시 0·1·2처럼 **소수의 정수**가 반복                  |
| **③ Target 포인터 + 거리** | `c++ struct HitInfo { void* pTarget; float fDist; }`               | \* TPS/FPS에서 ‘상대 객체’ 정보 재사용<br>\* `pTarget!=NULL` 여부만 봐도 조준 여부 판단 가능     |


###

애쉬 250
바스 350(주황)
캐서디 275
에코 225(파랑)
프레야 225
겐지 250
한조 250
